# Copyright (c) 2012 - D.M.A.Martin
#
#     This file is part of Python Mass Spec Analyzer (PyMSA).
#
#     Python Mass Spec Analyzer (PyMSA) is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     Python Mass Spec Analyzer (PyMSA) is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with Python Mass Spec Analyzer (PyMSA).  If not, see <http://www.gnu.org/licenses/>.")

from pyMSA import database
from MSPlot import ms1pep
import pyteomics.mass as mass
import warnings,subprocess,re


class PeptideDB:
    def __init__( self, host, user, password, database, dbtag=None):
        """
        @type host: string
        @param host: the host, where the MySQL database is located
        @type user: string
        @param user: database user name
        @type password: string
        @param password: the user's account password
        @type database: string
        @param database: the database name
        """
        self.host = host
        self.user = user
        self.password = password
        self.database = database 
        self.dbtag=dbtag
        self.dbid=None
        self.dbnames={}
        self._dbtaginit()
        if self.dbtag!=None:
            self._setdbid()

    def _setdbid(self):
        if self.dbtag !=None:
            self.dbid=self.dbnames.get(self.dbtag, None)

    def _dbtaginit(self):
        with database.ConnectMySQL(self.host, self.user, self.password,self.database) as sqlCon:
            cursor=sqlCon.cursor
            cursor.execute("SELECT database_id, database_name from peptide_fragment_database")
            for p in cursor.fetchall():
                self.dbnames[p[1]]=p[0]

    def createPeptideDatabase(self, dbtag, dbdescription=None, dbspecies=None):
        if self.dbnames.get(dbtag, None)!=None:
            raise Exception("Database with tag %s already exists"%dbtag)
        dbid=len(self.dbnames.keys())+1
        with database.ConnectMySQL(self.host, self.user, self.password,self.database) as sqlCon:
            cursor=sqlCon.cursor
            newid=None
            while newid==None:
                try:
                    cursor.execute("INSERT INTO peptide_fragment_database ( database_name, database_species, database_description) values ( %s,%s,%s)", (dbtag, dbspecies, dbdescription))
                    newid=dbid
                except Exception, e:
                    dbid=dbid+1
                    warnings.warn("Error inserting into DB: %s"%e)

            self.dbtag=dbtag
            self.dbid=dbid
            self.dbnames[dbtag]=self.dbid

    def loadDB(self, peptideList, minlen=1, maxlen=100):
        '''should take a list such as that generated by ms1pep.digestpeptidedb()'''
        sql='''INSERT INTO peptide_fragment (protein_accession,fragment_database_id, fragment_sequence, fragment_start, fragment_end, fragment_mono_mass) values (%s,%s,%s,%s,%s,%s)'''
        with database.ConnectMySQL(self.host, self.user, self.password,self.database) as sqlCon:
            cursor=sqlCon.cursor
            peps=0
            for p in peptideList:
                try:
                    assert p.has_key("sequence") and p.has_key("start") and p.has_key("end") and p.has_key("proteinID")
                    mr=mass.calculate_mass(p['sequence'])
                    if minlen<=len(p['sequence']) and maxlen >=len(p['sequence']):
                        cursor.execute(sql, (p['proteinID'],self.dbid, p['sequence'],p['start'],p['end'],mr))
                        peps=peps+1
                except Exception, e:
                    warnings.warn("error including sequence %s::%s : %s"%(p['proteinID'], p['sequence'], e))
            warnings.warn("Uploaded %s peptides to database %s"%(peps, self.dbtag))
                    

    def loadDigestFile(self, digestFile, sequenceFile):
        '''reads the output file from digest so it can be loaded into the current database. 
        digest must be run with -rfomat excel. 
        Sequence file headers must be in fasta simple format (>id description)
        >>> from pyMSA import peptideDB
        >>> db=peptideDB.PeptideDB("gjb-mysql-1","dmamartin", "BeepwiUt", "dmamartin", "Dicty_Trypsin")
        >>> peps=db.loadDigestFile("testdigest.dig", "testseq.fasta")

        '''
        #peptides=[]
        proteins={}
        warnings.warn("reading sequence file %s"%sequenceFile)
        pfh=open(sequenceFile, "r")
        seqid=''
        sequence=''
        line=pfh.readline()
        while line:
            if line[0]=='>':
                m=re.match(r'>([^ ]+)', line)
                if m:
                    seqid=m.group(1)
                    proteins[seqid]=''
            else:
                proteins[seqid]= proteins[seqid]+line.replace("\n","").replace("\r", "")
            line=pfh.readline()        
        pfh.close()
        warnings.warn("%s protein sequences read: %s ..."%(len(proteins.keys()), ",".join(proteins.keys()[0:5])))

        filehandle=open(digestFile, "r")
        line=filehandle.readline()
        #this should probably be rewritten to use a generator.
        warnings.warn("reading digest fragments from %s"%digestFile)
        while line:
            feats=line.split()
            if feats[0]=="SeqName":
                line=filehandle.readline()
                continue
            if False:
                args=["seqret", "%s:%s[%s:%s]"%(sequenceFile, feats[0], feats[1], feats[2]), "-osformat","raw", "-auto", "-stdout"]
                seqret=subprocess.Popen(args, stdout=subprocess.PIPE)
                if seqret==None:
                    raise Exception("Cannot retrieve %s from %s"%(args[1], sequenceFile))
                seq="".join(seqret.communicate()[0].split("\n"))
            try:
                seq=proteins[feats[0]][(int(feats[1])-1):int(feats[2])]
            except:
                warnings.warn("error retrieving sequence %s"%feats)
                line=filehandle.readline()
                continue
            yield {"proteinID":feats[0], "start":feats[1], "end": feats[2],"sequence":seq}
            #peptides.append({"proteinID":feats[0], "start":feats[1], "end": feats[2],"sequence":seq}) 
            line=filehandle.readline()
        filehandle.close()
        #warnings.warn("loading %s peptide fragments"%len(peptides))
        #return peptides
